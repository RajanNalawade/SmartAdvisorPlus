package sbilife.com.pointofsale_bancaagency.ekyc.utilites;import android.util.Base64;import android.util.Log;import org.w3c.dom.Document;import org.w3c.dom.Element;import org.w3c.dom.Node;import org.xml.sax.SAXException;import java.io.ByteArrayInputStream;import java.io.IOException;import java.io.StringWriter;import java.io.UnsupportedEncodingException;import java.nio.charset.StandardCharsets;import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;import java.security.PrivateKey;import java.security.PublicKey;import java.security.cert.X509Certificate;import javax.crypto.Cipher;import javax.xml.parsers.DocumentBuilder;import javax.xml.parsers.DocumentBuilderFactory;import javax.xml.parsers.ParserConfigurationException;import javax.xml.transform.Transformer;import javax.xml.transform.TransformerFactory;import javax.xml.transform.dom.DOMSource;import javax.xml.transform.stream.StreamResult;/** * Generates Sha1withRSA XML signatures. */public final class XmlSigner {  /** Log tag. */  private static final String LOG_TAG = "XmlSigner";  /**   * DER encoded ASN.1 identifier for SHA1 digest: "1.3.14.3.2.26".   */  private static final byte[] DER_SHA1_DIGEST_IDENTIFIER = new byte[]{0x30, 0x21, 0x30, 0x9, 0x6, 0x5, 0x2B, 0xe,      0x3, 0x2, 0x1a, 0x5, 0, 0x4, 0x14};  /** The characters needed for base 64 encoding. */  private static final char[] CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".toCharArray();  /**   * Hide constructor.   */  private XmlSigner() {  }  /**   * Generates Sha1withRSA XML signature for the specified XML content and   * private key.   *    * @param xml the XML content   * @param privateKey the private key to generate the signature   * @return the whole signature node XML string that should be inserted   * somewhere in the XML   * @throws XmlSignerException if the signature XML can not be generated   */  public static String generateXmlSignature(String inputXML, PrivateKey privateKey, X509Certificate certificate) {    //System.out.println("Private key: " + privateKey + "  X509 Cert: " + certificate.toString());    try {      String canonicalXML = canonicalizeXML(inputXML);      //String authNsXML = insertNameSpace(authCanonicalXML, "Auth", "http://www.uidai.gov.in/authentication/uid-auth-request/1.0");      //System.out.println("Namespace XML: " + authNsXML);      byte[] inputXMLBytes = canonicalXML.getBytes(StandardCharsets.UTF_8);    	      // Sha1 the authXMLBytes      byte[] inputXMLSha1Digest = sha1Digest(inputXMLBytes);    		        // encode the XML digest to base64 string      String base64AuthXMLSha1Digest = base64encode(inputXMLSha1Digest, false);      //Log.d("generateXmlSignature", "Base64 Auth XML Sha1 Digest: " + base64AuthXMLSha1Digest);      String signedInfo =    		  "<SignedInfo xmlns=\"http://www.w3.org/2000/09/xmldsig#\">"+			    "<CanonicalizationMethod Algorithm=\"http://www.w3.org/TR/2001/REC-xml-c14n-20010315\"/>"+			    "<SignatureMethod Algorithm=\"http://www.w3.org/2000/09/xmldsig#rsa-sha1\"/>"+			    "<Reference URI=\"\">"+			       "<Transforms>"+			         "<Transform Algorithm=\"http://www.w3.org/2000/09/xmldsig#enveloped-signature\"/>"+			       "</Transforms>"+			       "<DigestMethod Algorithm=\"http://www.w3.org/2000/09/xmldsig#sha1\"/>"+			       "<DigestValue>"+			           base64AuthXMLSha1Digest +                 "</DigestValue>"+			     "</Reference>"+			  "</SignedInfo>";      signedInfo = "<SignedInfo xmlns=\"http://www.w3.org/2000/09/xmldsig#\"><CanonicalizationMethod Algorithm=\"http://www.w3.org/TR/2001/REC-xml-c14n-20010315\"></CanonicalizationMethod><SignatureMethod Algorithm=\"http://www.w3.org/2000/09/xmldsig#rsa-sha1\"></SignatureMethod><Reference URI=\"\"><Transforms><Transform Algorithm=\"http://www.w3.org/2000/09/xmldsig#enveloped-signature\"></Transform></Transforms><DigestMethod Algorithm=\"http://www.w3.org/2000/09/xmldsig#sha1\"></DigestMethod><DigestValue>" + base64AuthXMLSha1Digest + "</DigestValue></Reference></SignedInfo>";      byte [] signedInfoBytes = signedInfo.getBytes(StandardCharsets.UTF_8); // canoncializeXMLBytes(signedInfo);            byte [] signedInfoDigest = sha1Digest(signedInfoBytes);                  // encode the digest identifier and the SHA1 digest in DER format      byte[] signedInfoDerSha1Digest = mergeArrays(DER_SHA1_DIGEST_IDENTIFIER, signedInfoDigest);            // initialize RSA cipher with the parameters from the private key      Cipher cipher = Cipher.getInstance("RSA/ECB/PKCS1PADDING");      cipher.init(Cipher.ENCRYPT_MODE, privateKey);      // encrypt the DER encoded SHA1 digest of signed info      byte[] signatureValueBytes = cipher.doFinal(signedInfoDerSha1Digest);      // encode the signature bytes into base64 string      String base64RsaSignatureValue = base64encode(signatureValueBytes, false);            String certStr = base64encode(certificate.getEncoded(), false);            String ownerStr = certificate.getSubjectX500Principal().getName();            String signatureFormat =             "<Signature xmlns=\"http://www.w3.org/2000/09/xmldsig#\">" +              signedInfo +               "%s" +               "<KeyInfo>"+                "<X509Data>"+                  "<X509SubjectName>"+                       ownerStr +   			      "</X509SubjectName>"+   			      "<X509Certificate>"+   			         certStr +   			      "</X509Certificate>"+   			    "</X509Data>"+   			  "</KeyInfo>"+   			"</Signature>";            String signatureXML = String.format(signatureFormat, "<SignatureValue>" + base64RsaSignatureValue + "</SignatureValue>");      return insertChildXml(canonicalXML, signatureXML, "Signature");    } catch (Throwable e) {      Log.e(LOG_TAG, "Error generating signature for XML", e);      return null;    }  }    public static void decryptSignature(String signature, PublicKey publicKey) {	  Cipher cipher;	try {		byte [] signedBytes = Base64.decode(signature, Base64.DEFAULT);		cipher = Cipher.getInstance("RSA/ECB/PKCS1PADDING");		cipher.init(Cipher.DECRYPT_MODE, publicKey);		byte [] decryptedSig = cipher.doFinal(signedBytes);	} catch (Exception e) {		// TODO Auto-generated catch block		e.printStackTrace();	}      }  public static byte[] canonicalizeXMLBytes(String inputXML) throws ParserConfigurationException,          SAXException, IOException {				return null;//    DocumentBuilder docBuilder = DocumentBuilderFactory.newInstance().newDocumentBuilder();////    InputStream is = new ByteArrayInputStream(inputXML.getBytes("UTF-8"));////    Document document = docBuilder.parse(is);////    nu.xom.Document nuDocument = DOMConverter.convert(document);////    ByteArrayOutputStream canonicalOs = new ByteArrayOutputStream();////    Canonicalizer canonicalizer = new Canonicalizer(canonicalOs, "http://www.w3.org/2001/10/xml-exc-c14n#");////    canonicalizer.write(nuDocument);//    return canonicalOs.toByteArray();  }  public static String canonicalizeXML(String inputXML) throws ParserConfigurationException,          SAXException, IOException {    try {//      InputStream is = new ByteArrayInputStream(inputXML.getBytes("UTF-8"));////      Builder parser = new Builder();////      nu.xom.Document nuDocument;////      nuDocument = parser.build(is);////      ByteArrayOutputStream canonicalOs = new ByteArrayOutputStream();////      Canonicalizer canonicalizer = new Canonicalizer(canonicalOs, "http://www.w3.org/TR/2001/REC-xml-c14n-20010315");////      canonicalizer.write(nuDocument);////      return canonicalOs.toString("UTF-8");    } catch (Exception e) {      // TODO Auto-generated catch block      e.printStackTrace();      return null;    }	return inputXML;  }  public static String insertNameSpace(String inputXML, String nodeTag, String ns) {    try {      DocumentBuilder db = DocumentBuilderFactory.newInstance().newDocumentBuilder();      Document inputDoc = db.parse(new ByteArrayInputStream(inputXML.getBytes(StandardCharsets.UTF_8)));      Element nsEle = (Element) inputDoc.getElementsByTagName(nodeTag).item(0);      nsEle.setAttribute("xmlns", ns);      DOMSource domSource = new DOMSource(inputDoc);      StringWriter writer = new StringWriter();      StreamResult result = new StreamResult(writer);      TransformerFactory tf = TransformerFactory.newInstance();      Transformer transformer = tf.newTransformer();      transformer.transform(domSource, result);      String retStr = writer.toString();      return retStr;    } catch (Exception e) {      // TODO Auto-generated catch block      e.printStackTrace();      return null;    }  }    public static String insertChildXml(String inputXML, String childXML, String childTag) {    try {      DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();      dbf.setValidating(false);      DocumentBuilder db = dbf.newDocumentBuilder();      Document inputDoc = db.parse(new ByteArrayInputStream(inputXML.getBytes(StandardCharsets.UTF_8)));      Document childDoc = db.parse(new ByteArrayInputStream(childXML.getBytes(StandardCharsets.UTF_8)));      Element childNode = (Element) childDoc.getElementsByTagName(childTag).item(0);      Node copiedNode = inputDoc.importNode(childNode, true);      inputDoc.getDocumentElement().appendChild(copiedNode);      DOMSource domSource = new DOMSource(inputDoc);      StringWriter writer = new StringWriter();      StreamResult result = new StreamResult(writer);      TransformerFactory tf = TransformerFactory.newInstance();      Transformer transformer = tf.newTransformer();      transformer.transform(domSource, result);      String retStr = writer.toString();      return retStr;    } catch (Exception e) {      // TODO Auto-generated catch block      e.printStackTrace();      return null;    }  }   /**   * Merges two byte arrays in one.   *    * @param array1 the first array   * @param array2 the second array   * @return merged array   */  public static byte[] mergeArrays(byte[] array1, byte[] array2) {    byte[] temp = new byte[array1.length + array2.length];    System.arraycopy(array1, 0, temp, 0, array1.length);    System.arraycopy(array2, 0, temp, array1.length, array2.length);    return temp;  }  /**   * Generates SHA-1 digest of the provided data.   *    * @param data the data to digest   * @return SHA-1 digest of the provided data.   */  public static byte[] sha1Digest(byte[] data) {    MessageDigest mdSha1 = null;    try {      mdSha1 = MessageDigest.getInstance("SHA-1");    } catch (NoSuchAlgorithmException e1) {      Log.e(LOG_TAG, "Error initializing SHA1 message digest");    }    mdSha1.update(data);    byte[] sha1hash = mdSha1.digest();    return sha1hash;  }  /**   * Generates SHA-256 digest of the provided data.   *    * @param data the data to digest   * @return SHA-256 digest of the provided data.   */  public static byte[] sha256Digest(byte[] data) {    MessageDigest mdSha256 = null;    try {      mdSha256 = MessageDigest.getInstance("SHA-256");    } catch (NoSuchAlgorithmException e1) {      Log.e(LOG_TAG, "Error initializing SHA1 message digest");    }    mdSha256.update(data);    byte[] sha256hash = mdSha256.digest();    return sha256hash;  }  /**   * Encoded byte arrays into Base64 strings.   *    * @param data the byte array to encode   * @param wrapLines <code>true</code> to add \r\n   * @return base64 encoded string   */  public static String base64encode(byte[] data, boolean wrapLines) {    int length = data.length;    StringBuilder sb = new StringBuilder(length * 3 / 2);    int end = length - 3;    int i = 0;    int n = 0;    while (i <= end) {      int d = ((((int) data[i]) & 0x0ff) << 16) | ((((int) data[i + 1]) & 0x0ff) << 8)          | (((int) data[i + 2]) & 0x0ff);      sb.append(CHARS[(d >> 18) & 63]);      sb.append(CHARS[(d >> 12) & 63]);      sb.append(CHARS[(d >> 6) & 63]);      sb.append(CHARS[d & 63]);      i += 3;      if (n++ >= 14) {        n = 0;        if (wrapLines) {          sb.append("\r\n");        }      }    }    if (i == length - 2) {      int d = ((((int) data[i]) & 0x0ff) << 16) | ((((int) data[i + 1]) & 255) << 8);      sb.append(CHARS[(d >> 18) & 63]);      sb.append(CHARS[(d >> 12) & 63]);      sb.append(CHARS[(d >> 6) & 63]);      sb.append("=");    } else if (i == length - 1) {      int d = (((int) data[i]) & 0x0ff) << 16;      sb.append(CHARS[(d >> 18) & 63]);      sb.append(CHARS[(d >> 12) & 63]);      sb.append("==");    }    return sb.toString();  }}